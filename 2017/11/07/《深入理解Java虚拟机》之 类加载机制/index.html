<!doctype html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JVM,">








  <link rel="shortcut icon" type="image/x-icon" href="/apple-touch-icon.png?v=5.1.1">






<meta name="description" content="虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。这就是虚拟机的类加载机制。">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解Java虚拟机》之 类加载机制">
<meta property="og:url" content="http://yoursite.com/2017/11/07/《深入理解Java虚拟机》之 类加载机制/index.html">
<meta property="og:site_name" content="小白爬坑之旅">
<meta property="og:description" content="虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。这就是虚拟机的类加载机制。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-17T02:22:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《深入理解Java虚拟机》之 类加载机制">
<meta name="twitter:description" content="虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。这就是虚拟机的类加载机制。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/07/《深入理解Java虚拟机》之 类加载机制/">





  <title>《深入理解Java虚拟机》之 类加载机制 | 小白爬坑之旅</title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小白爬坑之旅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/07/《深入理解Java虚拟机》之 类加载机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lollipop">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/AcFun.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白爬坑之旅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                《深入理解Java虚拟机》之 类加载机制
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-07T21:21:26+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。这就是虚拟机的类加载机制。<a id="more"></a></p>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析这3个部分统称为连接。</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段开始之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，这里写的是按部就班的“开始”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用激活另外一个阶段。</p>
<p>什么情况下需要开始类加载的一个阶段（加载），Java 虚拟机规范并没有强制约束。但是对于初始化阶段，虚拟机规范则严格规定了有且只有5种情况必须立即对类进行初始化（而加载、验证、准备自然要在之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或者设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li>
<li>当初始化一个类的时候，如果发现父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要需要指定一个要执行的主类（包括 main()  方法的那个类），虚拟机会先触发这个主类。</li>
<li>当使用 JDK 1.7的动态语言支持时，如果一个  java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>这5中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。下面举3个被动引用的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示一</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码运行只会输出“SuperClass init!”，而不会输出“SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类中定义的静态字段，只会触发父类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示二</span></span><br><span class="line"><span class="comment"> * 通过数组定义来引用类，不会触发类的初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args )</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后发现并没有触发 SuperClass 的初始化阶段。但是这段代码里面触发了另一个类的初始化阶段，它是一个由虚拟机自动生成的、直接继承于 java.lang.Object 的子类，创建动作由字节码指令 newarray 触发。这个类代表了一个元素类型为 SuperClass 的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为 public 的 length 属性和 clone() 方法）都实现在这个类里。Java 语言中对数组的访问比 C/C++ 相对安全是因为这个类封装了数组元素的访问方法，而 C/C++ 直接翻译为对数组指针的移动。在 Java 语言中，当检查到发生数组越界时会抛出 java.lang.ArrayIndexOutOfBoundsException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上并没引用到定义常量的类，因此不会触发定义常量的类的初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args )</span> </span>&#123;</span><br><span class="line">		System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行也并没有输出“ConstClass init”，因为其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了 NotInitialization 类的常量池中。实际上 NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 文件之后就不存在任何联系了。</p>
<font color="#0099ff" face="黑体">接口的加载过程和类的加载过程稍微有些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的。上面代码都是使用 “static ｛ ｝”来输出初始化消息的，而接口中不能使用“ static ｛ ｝”，但编译器会为接口生成“&lt;clinit&gt;()” 类构造器，用于初始化接口中所定义的成员变量。接口和类真正有所区别的是前面讲述的5中情况中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用父接口中定义的常量）才会初始化。</font>

<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成一下三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口。</li>
</ol>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的 loadClass() 方法）。</p>
<p>数组类则不一样，数组类本身并不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类和类加载器仍然有很密切的关系，因为数组类的元素类型（指数组去掉维度的类型）最终是要靠加载器去创建，一个数组类的创建过程遵循如下规则：</p>
<ol>
<li>如果数组类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识。</li>
<li>如果数组类的组件类型不是引用类型（如 int[ ] 数组），Java 虚拟机会把数组 C 标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li>
</ol>
<p>加载阶段完成后，二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机自行定义。然后在堆中实例化一个 java.lang.Class 对象，这个对象将作为程序访问方法区中这些类型数据的外部接口。</p>
<p>加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能就已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间依然保持着固定的先后顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上来看，验证阶段大致上会完成下面4个阶段的检验工作：</p>
<ol>
<li><p>文件格式验证。第一阶段要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 的编码的数据。</li>
<li><p>Class 文件中的各个部分及文件本身是否有被删除的或附加的其他信息。</p>
<p>……</p>
</li>
</ul>
<p>实际上，第一阶段验证工作远不止上面这些。<font color="#0099ff" face="黑体">该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才能进入内存的方法区进行存储，所有后面3个阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</font></p>
</li>
<li><p>元数据验证。第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，可能包括以下验证点：</p>
<ul>
<li>这个类是否有父类。</li>
<li>这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现了不符合规则的方法重载，例如方法参数都一样，但返回类型却不同等）。</li>
</ul>
<font color="#0099ff" face="黑体">第二阶段的目的主要是对元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</font>
</li>
<li><p>字节码验证。第三阶段是整个验证过程中最复杂的的一个阶段，<font color="#0099ff" face="黑体">主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完检验后，这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的时间</font>，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个 int 类型的数据，使用时却按 long 类型来加载入本地变量表。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li><p>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</p>
<p> ……</p>
</li>
</ul>
<p>由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在 JDK 1.6之后的javac 编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本块（按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查 StackMapTable 属性中的记录是否合法即可。理论上 StackMapTable 属性也存在错误或被篡改的可能。</p>
</li>
<li><p>符号引用验证。最后一个阶段检验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段（解析阶段）中发生。符号引用验证可以看作是对类自身以外（常量池中各种符号引用）的信息进行匹配性校验，通常需要校验一下内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li><p>符号引用中的类、字段、方法的访问性是否可以被当前类访问。</p>
<p> ……</p>
</li>
</ul>
<font color="#0099ff" face="黑体">符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个 java.lang.IncompatibleClassChangeError 异常的子类，如 java.lang.IllegalAccessError、java.lang.noSuchFieldError、java.lang.noSuchMehodError 等。</font>

</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将在对象实例化的时候随着对象一起分配在 Java 堆。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那变量 value 在准备阶段过后的初始值是0而不是123，因为这时候尚未执行任何 Java 方法，而把123赋值给 value 的 putstatic 指令是程序被编译后，存放在类构造器 &lt;clinit&gt;() 方法中，所以把 value 赋值为123的动作将在初始化阶段才会执行。特殊情况下：如果类字段的字段属性中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，例如 value 的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>编译时 javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置为 value 赋值为 123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内符号引用替换为直接引用的过程。符号引用和直接引用关联如下：</p>
<ol>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的引用到目标即可。符号引用和虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标就必定已经在内存中。</li>
</ol>
<p>虚拟机规范中并未规定解析阶段发生的具体时间，只要求在执行 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield 和 putstatic 这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要判断到底是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_invokeDynamic_info 7中常量类型。下面介绍前4种：</p>
<ol>
<li><p>类或接口的解析。</p>
<p>假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析过程需要以下三个步骤：</p>
<ul>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C，在加载过程中，由于元数据验证、字节码验这个的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或者接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似”［Ljava/lang/Integer“的形式，那将会按照第一点的规则加载数组元素类型。接着由虚拟机生成一个代表此数组维度的数组对象。</li>
<li>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限，如果发现不具备权限，将抛出 java.lang.IllegalAccessError 异常。</li>
</ul>
</li>
<li><p>字段解析。</p>
<p>要解析一个未解析过的字段符号引用，首先将会对字段表内 class_index项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所述的类或接口的符号引用。如果在解析这个类或接口符号引用的过程出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。</p>
<ul>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是 java.lang.Object 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出 java.lang.NoSuchFieldError 异常。</li>
</ul>
<p>如果查找过程中成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出 java.lang.IllegalAccessError 异常。</p>
</li>
<li><p>类方法解析。</p>
<p>类方法解析的第一个步骤和字段解析一样，也需要先解析出类方法表 class_index 项中索引的方法所属类或接口的符号引用，如果解析成功，我们依然用C来表示这个类，接下来虚拟机进行后续的类方法搜索：</p>
<ul>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index 中索引的是个接口，则直接抛出 java.lang.IncompatibleClassError 异常。</li>
<li>如果通过第一步，在类C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口中递归查找是否有简单名称和字段描述符都与目标相匹配的方法，如果存在匹配的方法，说明C是一个抽象类，这是查找结束，抛出 java.lang.AbstractMethodError 异常。</li>
<li>否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError 异常。</li>
</ul>
<p>最后，如果查找过程中成功返回了引用，将会对这个方法进行权限验证，如果发现不具备对方法的访问权限，将抛出 java.lang.IllegalAccessError 异常。</p>
</li>
<li><p>接口方法解析。</p>
<p>接口方法也需要先解析出接口方法表 class_index 项中索引的方法所属类或接口的符号引用，如果解析成功，我们依然用C来表示这个类，接下来虚拟机进行后续的类方法搜索：</p>
<ul>
<li>与类方法解析不同，如果在类方法表中发现class_index 中索引的是个类而不是接口，则直接抛出 java.lang.IncompatibleClassError 异常。</li>
<li>否则，在接口C中查找是否有简单名称和字段描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到 java.lang.Object 类（查找范围会包括 Object 类）为止，看是否有简单名称和字段描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告查找失败，抛出 java.lang.NoSuchMethodError 异常。</li>
</ul>
<p>由于接口中的方法默认都是 public 的，所以不存在访问权限的问题，因此接口方法的符号引用应当不会抛出 java.lang.IllegalAccessError 异常。</p>
</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。</p>
<p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者换句话说，初始化阶段是执行类构造器 &lt;clinit&gt;() 方法的过程。</p>
<ul>
<li><p>&lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，<font color="#0099ff" face="黑体">静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</font>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;						<span class="comment">//给变量赋值可以正常通过编译</span></span><br><span class="line">        System.out.println(i);		<span class="comment">//编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;clinit&gt;() 方法与类的构造方法（或者说实例构造器 &lt;init&gt;() 方法）不同，它不需要显示调用父类构造器，虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前，父类的 &lt;clinit&gt;() 方法已经执行完毕。</p>
</li>
<li><p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下代码，字段 B 的值将会是2而不是1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;clinit&gt;() 方法对于类或接口来说并不是必须的，如果一个类并没有静态语句块，也没有对变量的赋值操作，那么编译器就可以不为这个类生成 &lt;clinit&gt;() 方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口和类一样都会生成 &lt;clinit&gt;() 方法，但接口和类不同的是，<font color="#0099ff" face="黑体">执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法，只有当父接口的中定义的变量使用时，父接口才会初始化，另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</font></p>
</li>
<li><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法 在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;clinit&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有很耗时的操作，就可能导致多个线程阻塞，在实际应用中，这种阻塞往往是很隐蔽的。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//如果不加上这个if语句，编译器将提示“Initializer dose not complete normally”并拒绝编译</span></span><br><span class="line">      	<span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"init DeadLoopClass"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"start"</span>);</span><br><span class="line">            DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"run over"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，即一条线程在死循环模拟长时间操作，另一条线程在阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,mian]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,mian]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,mian]init DeadLoopClass</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><font color="#0099ff" face="黑体">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换句话说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</font>

<p>这里说的“相等”，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定情况等。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从 Java 虚拟机角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有的其他类加载器，这些类加载器由 Java 语言实现，独立于 Java 虚拟机外部，并且全部都继承自抽象类 java.lang.ClassLoader。</p>
<p>从开发人员角度可以划分的更细一点，绝大部分 Java 程序都会使用到下面3中系统提供的类加载器。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）。这个类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那么直接使用 null 代替即可。</li>
<li>扩展类加载器（Extension ClassLoader）。它负责加载  &lt;JAVA_HOME&gt;\lib\ext 目录中的， 或者被 java.ext.dirs 系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）。由于这个类加载器时 ClassLoader 中的 getSystemClassLoader() 方法中的返回值，所以一般也称它为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自己定义过自己的类加载器，一般情况下这个就是程序中默认的类加载。</li>
</ul>
<font color="#0099ff" face="黑体">双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</font>

<p>使用双亲委派模型的一个显而易见的好处就是， Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如 java.lang.Object，它存放在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类计载器环境中都是同一个类。我们尝试去编写一个和 rt.jar 类库中已有类重名的 Java 类，将会发现能正常通过编译，但永远无法被加载运行。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/05/《深入理解Java虚拟机》之GC/" rel="next" title="《深入理解Java虚拟机》之GC">
                <i class="fa fa-chevron-left"></i> 《深入理解Java虚拟机》之GC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/09/《深入理解Java虚拟机》之 字节码执行引擎/" rel="prev" title="《深入理解Java虚拟机》之 字节码执行引擎">
                《深入理解Java虚拟机》之 字节码执行引擎 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/AcFun.png" alt="Lollipop">
          <p class="site-author-name" itemprop="name">Lollipop</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Jimmy2Angel" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:a1334416010@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">1.</span> <span class="nav-text">虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的时机"><span class="nav-number">1.1.</span> <span class="nav-text">类加载的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的过程"><span class="nav-number">1.2.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">1.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">1.2.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">1.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">1.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">1.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">1.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与类加载器"><span class="nav-number">1.3.1.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">1.3.2.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lollipop</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
